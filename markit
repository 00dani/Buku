#!/usr/bin/python3
#
# Bookmark management utility
#
# Copyright (C) 2015 Arun Prakash Jana <engineerarun@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with markit.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import sqlite3
from getopt import getopt, GetoptError
import readline
import webbrowser

# Globals
addurl = False
deletedb = False
showdb = False
search = False
entry = "0"
updatedb = False

def usage():
    print("Usage: markit [OPTIONS] KEYWORDS...")
    print("Bookmark manager.\n")
    print("Options")
    print("  -a URL tag entry1, tag entry2, ...    print all bookmarks")
    print("  -d                                    delete ALL bookamrks")
    print("  -p                                    print all bookmarks")
    print("  -s string(s)                          search all bookmarks for a tag or string")
    print("  -u N                                  update index number (from output of -p)")
    print("                                        any other input shows help and exits markit\n")
    print("Version 0.1")
    print("Copyright (C) 2015 Arun Prakash Jana <engineerarun@gmail.com>")
    print("Webpage: https://github.com/jarun/markit")
    sys.exit(1)

def initdb():
    # Create a connection
    conn = sqlite3.connect('bookmarks.db')
    cur = conn.cursor()

    # Create table if it doesn't exist
    cur.execute('''CREATE TABLE if not exists bookmarks
               (id integer PRIMARY KEY AUTOINCREMENT, URL text NOT NULL UNIQUE, tags text, metadata text)''')
    conn.commit()
    return (conn, cur)

def addentry(conn, cur, keywords):
    tags = ','
    url = keywords[0]
    for tag in keywords[1:]:
        if tags[-1] == ",":
            tags += tag
        else:
            tags += " " + tag

    if tags[-1] != ",":
        tags += ","

    try:
        cur.execute('INSERT INTO bookmarks(URL, tags, metadata) VALUES (?, ?, ?)', (url, tags, ''))
        conn.commit()
    except sqlite3.IntegrityError:
        print("URL already exists")

def searchdb(cur, keywords):
    searchtag = ''
    searchkey = keywords[0]
    for token in keywords:
        searchtag += token + " "

    searchtag = ',' + searchtag[0:-1] + ','

    count = 0
    results = []
    for row in cur.execute("SELECT * FROM bookmarks WHERE tags LIKE ('%' || ? || '%') \
                            OR tags LIKE ('%' || ? || '%') \
                            OR URL LIKE ('%' || ? || '%')", (searchtag, searchkey, searchkey)):
        results.append(row[1])
        count += 1
        print("\x1B[1m\x1B[93m%d. \x1B[0m\x1B[92m%s\x1B[0m" % (count, row[1]))

    if count == 0:
        return

    while True:
        nav = input("Index number to open: ")
        if is_int(nav):
            index = int(nav) - 1
            if index < 0:
                print("Index out of bound.")
                continue

            try:
                _stderr = os.dup(2)
                os.close(2)
                _stdout = os.dup(1)
                os.close(1)
                fd = os.open(os.devnull, os.O_RDWR)
                os.dup2(fd, 2)
                os.dup2(fd, 1)
                try:
                    webbrowser.open(results[int(nav) - 1])
                finally:
                    os.close(fd)
                    os.dup2(_stderr, 2)
                    os.dup2(_stdout, 1)
            except IndexError:
                print("Index out of bound.")
        else:
            break

def updateentry(conn, cur, entry, keywords):
    tags = ','
    url = keywords[0]
    for tag in keywords[1:]:
        if tags[-1] == ",":
            tags += tag
        else:
            tags += " " + tag

    if tags[-1] != ",":
        tags += ","

    cur.execute("UPDATE bookmarks SET URL = ?, tags = ?, metadata = '' WHERE id = ?", (url, tags, int(entry)))
    conn.commit()
    if cur.rowcount == 1:
        print("Updated")
    else:
        print("No matching index")

def cleardb(conn, cur):
    cur.execute('DROP TABLE if exists bookmarks')
    conn.commit()

def printtable(cur):
    for row in cur.execute('SELECT * FROM bookmarks'):
        print("\x1B[1m\x1B[93m%s. \x1B[0m\x1B[92m%s\x1B[0m\n\t[TAGS] %s\n\t[META] %s" % (row[0], row[1], row[2][1:-1], row[3]))

def is_int(string):
    try:
        int(string)
        return True
    except:
        return False

# Main starts here
# ----------------
optlist = None
keywords = None

if len(sys.argv) < 2:
    usage()

try:
    optlist, keywords = getopt(sys.argv[1:], "u:adps")
    if len(optlist) < 1:
        usage()

    for opt in optlist:
        if opt[0] == "-a":
            if updatedb == True:
                print("You can either add or update in one instance\n")
                usage()

            addurl = True
        elif opt[0] == "-d":
            deletedb = True
        elif opt[0] == "-p":
            showdb = True
        elif opt[0] == "-s":
            search = True
        elif opt[0] == "-u":
            if addurl == True:
                print("You can either add or update in one instance\n")
                usage()
            if not opt[1].isdigit():
                usage()

            entry = opt[1]
            if int(entry) <= 0:
                usage()

            updatedb = True
except GetoptError as e:
    print("markit:", e)
    sys.exit(1)

conn, cur = initdb()

if addurl == True:
    if len(keywords) < 1:
        usage()

    addentry(conn, cur, keywords)

if search == True:
    if len(keywords) < 1:
        usage()

    searchdb(cur, keywords)

if updatedb == True:
    updateentry(conn, cur, entry, keywords)

if showdb == True:
    printtable(cur)

if deletedb == True:
    cleardb(conn, cur)

conn.close()
