#!/usr/bin/python3
#
# Bookmark management utility
#
# Copyright (C) 2015 Arun Prakash Jana <engineerarun@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with markit.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import sqlite3
from getopt import getopt, GetoptError
import readline
import webbrowser
import html.parser as HTMLParser
from http.client import HTTPConnection
from http.client import HTTPSConnection
from urllib.parse import urljoin, unquote

# Globals
addurl = False
addindex = None
online = False
delete = False
show = False
search = False
entry = None
update = False
debug = False



# Show usage of markit and exit
def usage():
    print("Usage: markit [OPTIONS] KEYWORDS...")
    print("Bookmark manager. Your private Google.\n")
    print("Options")
    print("  -a URL tag 1, tag 2, ...   add a bookmark with comma separated tags")
    print("  -d N                       delete entry at index N")
    print("  -D                         delete ALL bookmarks")
    print("  -i N                       add entry at index N, works with -a, use to fill deleted index")
    print("  -o                         fetch title info from web, works with -a or -u")
    print("  -p                         print all bookmarks, shows real index from database")
    print("  -s keyword(s)              search all bookmarks for a (partial) tag or keywords")
    print("  -u N                       update entry at index N (from output of -p)")
    print("  -z                         show debug information")
    print("                             you can either add or update or delete in one instance")
    print("                             any other option shows help and exits markit\n")
    print("Keys")
    print("  1-N                        open Nth search result in browser. Enter exits markit.\n")
    print("Version 0.1")
    print("Copyright (C) 2015 Arun Prakash Jana <engineerarun@gmail.com>")
    print("Webpage: https://github.com/jarun/markit")
    sys.exit(1)



# Initialize the database connection
# Create bookmarks table is not existing
def initdb():
    user = os.environ.get('USER')
    # Create a connection
    conn = sqlite3.connect('/home/' + user + '/.cache/bookmarks.db')
    cur = conn.cursor()

    # Create table if it doesn't exist
    cur.execute('''CREATE TABLE if not exists bookmarks \
               (id integer PRIMARY KEY, URL text NOT NULL UNIQUE, tags text, metadata text)''')
    conn.commit()
    return (conn, cur)



# Add a new bookmark or update an existing record
def AddUpdateEntry(conn, cur, keywords, entry):
    global online

    tags = ','
    url = keywords[0]
    for tag in keywords[1:]:
        if tags[-1] == ",":
            tags += tag
        else:
            tags += " " + tag

    if tags[-1] != ",":
        tags += ","

    meta = ''

    if online == True:
        secure = True
        if url.find("https://") >= 0:
            server = url[8:]
        elif url.find("http://") >= 0:
            secure = False
            server = url[7:]
        else:
            online = False

        if online == True:
            marker = server.find("/")
            if marker > 0:
                server = server[:marker]

            try:
                if debug:
                    print("server: [%s]" % server)
                if secure == True:
                    urlconn = HTTPSConnection(server, timeout=30)
                else:
                    urlconn = HTTPConnection(server, timeout=30)

                if debug:
                    print("URL: [%s]" % url)
                urlconn.request("GET", url)
                resp = urlconn.getresponse()
                if resp.status != 200:
                    # Handle first redirection
                    if resp.status in (301,302,):
                        redirurl = urljoin(url, resp.getheader('location', ''))
                        if redirurl.find("sorry/IndexRedirect?") >= 0:
                            print("ERROR: Connection blocked due to unusual activity.")
                        else:
                            urlconn.close()

                            secure = False
                            if url.find("https://") >= 0:
                               secure = True

                            if secure == True:
                                server = redirurl[8:]
                                marker = server.find("/")
                                if marker > 0:
                                    server = server[:marker]
                                urlconn = HTTPSConnection(server, timeout=30)
                            else:
                                server = redirurl[7:]
                                marker = server.find("/")
                                if marker > 0:
                                    server = server[:marker]
                                urlconn = HTTPConnection(server, timeout=30)

                            if debug:
                                print("Redir server: [%s]" % server)
                                print("Redir URL: [%s]" % redirurl)

                            urlconn.request("GET", redirurl)
                            resp = urlconn.getresponse()
                            if resp.status != 200:
                                print("ERROR on retry:", str(resp.status), ": ", resp.reason)
                                meta = ''
                            else:
                                parser = BMHTMLParser()
                                parser.feed(resp.read().decode('utf-8'))
                                if parser.data != None and parser.data.find("Error") < 0:
                                    meta = parser.data
                    else: # if resp.status in (301,302,):
                        print("ERROR:", str(resp.status), ": ", resp.reason)
                        meta = ''
                else: # if resp.status != 200:
                    parser = BMHTMLParser()
                    parser.feed(resp.read().decode('utf-8'))
                    if parser.data != None and parser.data.find("Error") < 0:
                        meta = parser.data
            except Exception as e:
                print("Exception: %s" % e)
                meta = ''
            finally:
                urlconn.close()

    print("Title: [%s]" % meta)

    if entry == None: # Add a new entry
        try:
            if addindex == None:
                cur.execute('INSERT INTO bookmarks(URL, tags, metadata) VALUES (?, ?, ?)', (url, tags, meta,))
            else:
                cur.execute('INSERT INTO bookmarks(id, URL, tags, metadata) VALUES (?, ?, ?, ?)', (int(addindex), url, tags, meta,))
            conn.commit()
        except sqlite3.IntegrityError:
            print("Index or URL already exists")
    else: # Update an existing entry
        try:
            cur.execute("UPDATE bookmarks SET URL = ?, tags = ?, metadata = ? WHERE id = ?", (url, tags, meta, int(entry),))
            conn.commit()
            if cur.rowcount == 1:
                print("Updated")
            else:
                print("No matching index")
        except sqlite3.IntegrityError:
            print("URL already exists")



# Search the database for a tag or mathcing URL or Title info
def searchdb(cur, keywords):
    searchtag = ''
    for token in keywords:
        searchtag += token + " "
    searchtag = searchtag[0:-1]

    arguments = []
    arguments.append(searchtag)
    placeholder = "'%' || ? || '%'"
    query = "SELECT url, metadata FROM bookmarks WHERE tags LIKE (%s)" % placeholder
    for token in keywords:
        query += " OR URL LIKE (%s) OR metadata LIKE (%s)" % (placeholder, placeholder)
        arguments.append(token)
        arguments.append(token)
    if debug:
        print("%s, (%s)" % (query, arguments))

    count = 0
    results = []
    for row in cur.execute(query, arguments):
        results.append(row[0])
        count += 1
        print("\x1B[1m\x1B[93m%d. \x1B[0m\x1B[92m%s\x1B[0m\n\t%s" % (count, row[0], row[1]))

    if count == 0:
        return

    print("")

    while True:
        nav = input("Index number to open: ")
        if is_int(nav):
            index = int(nav) - 1
            if index < 0:
                print("Index out of bound.")
                continue

            try:
                _stderr = os.dup(2)
                os.close(2)
                _stdout = os.dup(1)
                os.close(1)
                fd = os.open(os.devnull, os.O_RDWR)
                os.dup2(fd, 2)
                os.dup2(fd, 1)
                try:
                    openurl = unquote(results[int(nav) - 1])
                    openurl = openurl.replace("%22", "\"")
                    webbrowser.open(openurl)
                finally:
                    os.close(fd)
                    os.dup2(_stderr, 2)
                    os.dup2(_stdout, 1)
            except IndexError:
                print("Index out of bound.")
        else:
            break



# Delete a single record or remove the table
def cleardb(conn, cur, entry):
    if entry == None: # Remove the table
        cur.execute('DROP TABLE if exists bookmarks')
        conn.commit()
    else: # Remove a single entry
        try:
            cur.execute("DELETE FROM bookmarks WHERE id = ?", (int(entry),))
            conn.commit()
            if cur.rowcount == 1:
                print("Removed")
            else:
                print("No matching index")
        except IndexError:
                print("Index out of bound.")



# Print all records in the table
def printdb(cur):
    for row in cur.execute('SELECT * FROM bookmarks'):
        print("\x1B[1m\x1B[93m%s. \x1B[0m\x1B[92m%s\x1B[0m\n\t[TAGS] %s\n\t[META] %s" % (row[0], row[1], row[2][1:-1], row[3]))



# Check if a value is a digit
def is_int(string):
    try:
        int(string)
        return True
    except:
        return False



# Parse HTML page for Title info
class BMHTMLParser(HTMLParser.HTMLParser):
    def __init__(self):
        HTMLParser.HTMLParser.__init__(self)
        self.inTitle = False
        self.data = ""
        self.lasttag = None

    def handle_starttag(self, tag, attrs):
        self.inTitle = False
        if tag == "title":
            self.inTitle = True
            self.lasttag = tag

    def handle_endtag(self, tag):
        if tag == "title":
            self.inTitle = False

    def handle_data(self, data):
        if self.lasttag == "title" and self.inTitle == True:
            self.data += data



# Main starts here
# ----------------
optlist = None
keywords = None

if len(sys.argv) < 2:
    usage()

# Check cmdline options
try:
    optlist, keywords = getopt(sys.argv[1:], "d:i:u:aDopsz")
    if len(optlist) < 1:
        usage()

    for opt in optlist:
        if opt[0] == "-a":
            if update == True or delete == True:
                print("You can either add or update or delete in one instance\n")
                usage()

            addurl = True
        elif opt[0] == "-d":
            if addurl == True or update == True:
                print("You can either add or update or delete in one instance\n")
                usage()

            if not opt[1].isdigit():
                usage()

            entry = opt[1]
            if int(entry) <= 0:
                usage()

            delete = True
        elif opt[0] == "-D":
            if addurl == True or update == True:
                print("You can either add or update or delete in one instance\n")
                usage()

            delete = True
        elif opt[0] == "-i":
            if not opt[1].isdigit():
                usage()

            addindex = opt[1]
            if int(addindex) <= 0:
                usage()
        elif opt[0] == "-o":
            online = True
        elif opt[0] == "-p":
            show = True
        elif opt[0] == "-s":
            search = True
        elif opt[0] == "-u":
            if addurl == True or delete == True:
                print("You can either add or update or delete in one instance\n")
                usage()

            if not opt[1].isdigit():
                usage()

            entry = opt[1]
            if int(entry) <= 0:
                usage()

            update = True
        elif opt[0] == "-z":
            debug = True
except GetoptError as e:
    print("markit:", e)
    sys.exit(1)

# Initilize the database and get handles
conn, cur = initdb()

# To insert (-i) a new record at user-defined index, -a option is must
if addindex != None and addurl == False:
    conn.close()
    usage()

# Call add or update record
if addurl == True or update == True:
    if len(keywords) < 1:
        conn.close()
        usage()

    AddUpdateEntry(conn, cur, keywords, entry)

# Search tags, URLs, Title info
if search == True:
    if len(keywords) < 1:
        conn.close()
        usage()

    searchdb(cur, keywords)

# Print all records
if show == True:
    printdb(cur)

# Remove a single record of all records
if delete == True:
    cleardb(conn, cur, entry)

# Close the connection before exiting
conn.close()
